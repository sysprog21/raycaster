#!/usr/bin/env bash

# Pre-commit hook for code style and static analysis
# Only analyzes files tracked by git

# Resolve symlinks to find the real script directory
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")" && pwd)"

# Source common utilities
common_script="${SCRIPT_DIR}/common.sh"
[ -r "$common_script" ] || { echo "[!] '$common_script' not found." >&2; exit 1; }
source "$common_script"

set_colors

RETURN=0

# Check for required tools
CLANG_FORMAT=$(which clang-format 2>/dev/null)
if [ -z "$CLANG_FORMAT" ]; then
    echo -e "${RED}[!] clang-format not installed. Unable to check source file format policy.${NC}" >&2
    exit 1
fi

CPPCHECK=$(which cppcheck 2>/dev/null)
if [ -z "$CPPCHECK" ]; then
    echo -e "${RED}[!] cppcheck not installed. Unable to perform static analysis.${NC}" >&2
    exit 1
fi

DIFF=$(which colordiff 2>/dev/null || echo diff)

# Get staged C/C++ files (NUL-delimited for safe filename handling)
mapfile -d '' FILES < <(get_staged_c_files)

# Check code formatting for staged files
for FILE in "${FILES[@]}"; do
    # Skip if file doesn't exist (deleted) or empty element
    [ -z "$FILE" ] && continue
    [ -f "$FILE" ] || continue

    nf=$(git checkout-index --temp "$FILE" | cut -f 1)
    tempdir=$(mktemp -d) || exit 1
    basename=$(basename "$FILE")

    source="${tempdir}/${basename}"
    mv "$nf" "$source"
    newfile=$(mktemp "${tempdir}/${basename}.XXXXXX") || exit 1
    cp .clang-format "$tempdir" 2>/dev/null || true
    $CLANG_FORMAT "$source" > "$newfile" 2>/dev/null
    $DIFF -u -p -B "${source}" "${newfile}"
    r=$?
    rm -rf "${tempdir}"

    if [ $r != 0 ]; then
        echo -e "${RED}[!] $FILE does not follow the consistent coding style.${NC}" >&2
        RETURN=1
    fi
done

if [ $RETURN -eq 1 ]; then
    echo "" >&2
    echo -e "${YELLOW}Make sure you indent as the following:${NC}" >&2
    echo "    clang-format -i <file>" >&2
    echo
fi

# Static analysis on git-tracked files only (NUL-delimited for safe handling)
mapfile -d '' TRACKED_FILES < <(get_tracked_c_files)

if [ ${#TRACKED_FILES[@]} -gt 0 ]; then
    CPPCHECK_OPTS="-I. -I./include --error-exitcode=1 --suppress=normalCheckLevelMaxBranches"

    # Run cppcheck on tracked files only
    $CPPCHECK $CPPCHECK_OPTS "${TRACKED_FILES[@]}" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        # Re-run to show errors
        echo -e "${RED}Static analysis errors:${NC}" >&2
        $CPPCHECK $CPPCHECK_OPTS "${TRACKED_FILES[@]}" 2>&1
        RETURN=1
        echo "" >&2
        echo -e "${RED}Fail to pass static analysis.${NC}" >&2
        echo
    fi
fi

exit $RETURN
