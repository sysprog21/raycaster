#!/usr/bin/env bash

# git-good-commit(1) - Git hook to help you write good commit messages.
# Released under the MIT License.
# https://github.com/tommarshall/git-good-commit

COMMIT_MSG_FILE="$1"
COMMIT_MSG_LINES=()
HOOK_EDITOR=
SKIP_DISPLAY_WARNINGS=0
declare -a WARNINGS

# Resolve symlinks to find the real script directory
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")" && pwd)"

# Source common utilities
common_script="${SCRIPT_DIR}/common.sh"
[ -r "$common_script" ] || { echo "[!] '$common_script' not found." >&2; exit 1; }
source "$common_script"

# Set the hook editor, using the same approach as git.
set_editor() {
  test -z "${HOOK_EDITOR}" && HOOK_EDITOR=$(git config --get core.editor)
  test -z "${HOOK_EDITOR}" && HOOK_EDITOR=$VISUAL
  test -z "${HOOK_EDITOR}" && HOOK_EDITOR=$EDITOR
  test -z "${HOOK_EDITOR}" && HOOK_EDITOR='vi'
}

# Output prompt help information.
prompt_help() {
  echo -e "${RED}$(cat <<-EOF
How to Write a Git Commit Message: https://chris.beams.io/posts/git-commit/
e - edit commit message
n - abort commit
? - print help
EOF
)${NC}"
}

# Add a warning with <line_number> and <msg>.
add_warning() {
  local line_number=$1
  local warning=$2
  WARNINGS[$line_number]="${WARNINGS[$line_number]}$warning;"
}

# Output warnings.
display_warnings() {
  if [ $SKIP_DISPLAY_WARNINGS -eq 1 ]; then
    SKIP_DISPLAY_WARNINGS=0
    return
  fi

  for i in "${!WARNINGS[@]}"; do
    printf "%-74s ${WHITE}%s${NC}\n" "${COMMIT_MSG_LINES[$(($i-1))]}" "[line ${i}]"
    IFS=';' read -ra WARNINGS_ARRAY <<< "${WARNINGS[$i]}"
    for ERROR in "${WARNINGS_ARRAY[@]}"; do
      echo -e " ${YELLOW}- ${ERROR}${NC}"
    done
  done

  echo
  echo -e "${RED}Read: https://chris.beams.io/posts/git-commit/${NC}"
}

# Read the contents of the commit msg into an array of lines.
read_commit_message() {
  COMMIT_MSG_LINES=()

  while IFS= read -r; do
    # Trim trailing spaces
    shopt -s extglob
    REPLY="${REPLY%%*( )}"
    shopt -u extglob

    # Ignore comments and scissor line
    [[ $REPLY =~ ^# ]] && continue
    [[ $REPLY =~ "# ------------------------ >8 ------------------------" ]] && break

    COMMIT_MSG_LINES+=("$REPLY")
  done < "$COMMIT_MSG_FILE"
}

# Known commit trailers
KNOWN_TRAILERS=(
  'Signed-off-by'
  'Reviewed-by'
  'Co-authored-by'
  'Acked-by'
  'Suggested-by'
  'Tested-by'
  'Reported-by'
  'CC'
  'Change-Id'
  'Closes'
  'Fixes'
)

# Build trailer regex
build_trailer_regex() {
  TRAILER_REGEX='^('
  for trailer in "${KNOWN_TRAILERS[@]}"; do
    TRAILER_REGEX+="$trailer|"
  done
  TRAILER_REGEX="${TRAILER_REGEX%|}):.*"
}

# Validate the contents of the commit msg against good commit guidelines.
validate_commit_message() {
  WARNINGS=()

  # Capture the subject, remove 'squash! ' prefix if present
  COMMIT_SUBJECT=${COMMIT_MSG_LINES[0]/#squash! /}

  # Empty commit - nothing to validate
  COMMIT_MSG_STR="${COMMIT_MSG_LINES[*]}"
  test -z "${COMMIT_MSG_STR[*]// }" && return

  # Fixup commits skip validation
  [[ $COMMIT_SUBJECT == 'fixup! '* ]] && return

  # 1. Separate subject from body with a blank line
  test ${#COMMIT_MSG_LINES[@]} -lt 1 || test -z "${COMMIT_MSG_LINES[1]}"
  test $? -eq 0 || add_warning 2 "Separate subject from body with a blank line"

  # 2. Limit the subject line to 50 characters (configurable)
  local subject_max_length=$(git config --get hooks.goodcommit.subjectmaxlength || echo '50')
  test "${#COMMIT_SUBJECT}" -le "$subject_max_length"
  test $? -eq 0 || add_warning 1 "Limit the subject line to $subject_max_length characters (${#COMMIT_SUBJECT} chars)"

  # 3. Capitalize the subject line
  [[ ${COMMIT_SUBJECT} =~ ^[[:blank:]]*([[:upper:]]{1}[[:lower:]]*|[[:digit:]]+)([[:blank:]]|[[:punct:]]|$) ]]
  test $? -eq 0 || add_warning 1 "Capitalize the subject line"

  # 4. Do not end the subject line with a period
  [[ ${COMMIT_SUBJECT} =~ [^\.]$ ]]
  test $? -eq 0 || add_warning 1 "Do not end the subject line with a period"

  # 5. Use the imperative mood in the subject line
  IMPERATIVE_MOOD_DENYLIST=(
    added          adds          adding
    adjusted       adjusts       adjusting
    amended        amends        amending
    avoided        avoids        avoiding
    bumped         bumps         bumping
    changed        changes       changing
    checked        checks        checking
    committed      commits       committing
    copied         copies        copying
    corrected      corrects      correcting
    created        creates       creating
    decreased      decreases     decreasing
    deleted        deletes       deleting
    disabled       disables      disabling
    dropped        drops         dropping
    duplicated     duplicates    duplicating
    enabled        enables       enabling
    excluded       excludes      excluding
    fixed          fixes         fixing
    handled        handles       handling
    implemented    implements    implementing
    improved       improves      improving
    included       includes      including
    increased      increases     increasing
    installed      installs      installing
    introduced     introduces    introducing
    merged         merges        merging
    moved          moves         moving
    pruned         prunes        pruning
    refactored     refactors     refactoring
    released       releases      releasing
    removed        removes       removing
    renamed        renames       renaming
    replaced       replaces      replacing
    resolved       resolves      resolving
    reverted       reverts       reverting
    showed         shows         showing
    tested         tests         testing
    tidied         tidies        tidying
    updated        updates       updating
    used           uses          using
  )

  shopt -s nocasematch
  for DENYLISTED_WORD in "${IMPERATIVE_MOOD_DENYLIST[@]}"; do
    [[ ${COMMIT_SUBJECT} =~ ^[[:blank:]]*$DENYLISTED_WORD ]]
    test $? -eq 0 && add_warning 1 "Use the imperative mood in the subject line, e.g., 'Fix' not 'Fixed'" && break
  done
  shopt -u nocasematch

  # 6. Wrap the body at 72 characters
  URL_REGEX='^[[:blank:]]*(https?|ftp|file)://[-A-Za-z0-9+&@#/%?=~_|!:,.;]*[-A-Za-z0-9+&@#/%=~_|]'

  for i in "${!COMMIT_MSG_LINES[@]}"; do
    LINE_NUMBER=$((i+1))
    local line="${COMMIT_MSG_LINES[$i]}"

    # Skip URLs and trailers
    if [[ "$line" =~ $URL_REGEX ]] || [[ "$line" =~ $TRAILER_REGEX ]]; then
      continue
    fi

    test "${#line}" -le 72
    test $? -eq 0 || add_warning $LINE_NUMBER "Wrap the body at 72 characters (${#line} chars)"
  done

  # 7. Do not write single-worded commits
  COMMIT_SUBJECT_WORDS=(${COMMIT_SUBJECT})
  test "${#COMMIT_SUBJECT_WORDS[@]}" -gt 1
  test $? -eq 0 || add_warning 1 "Do not write single-word commits"

  # 8. Do not start the subject line with whitespace
  [[ ${COMMIT_SUBJECT} =~ ^[[:blank:]]+ ]]
  test $? -eq 1 || add_warning 1 "Do not start the subject line with whitespace"

  # 9. Disallow conventional commit format (wastes characters)
  if [[ ${COMMIT_SUBJECT} =~ ^[a-z]+\([^\)]+\):[[:space:]] ]] || \
     [[ ${COMMIT_SUBJECT} =~ ^[a-z]+!?:[[:space:]] ]]; then
    add_warning 1 "Avoid conventional commit format (e.g., 'feat:', 'fix:'). Write a direct, descriptive subject"
  fi

  # 10. Disallow parentheses in commit subject
  if [[ ${COMMIT_SUBJECT} =~ [\(\)] ]]; then
    add_warning 1 "Avoid using parentheses '()' in commit subjects"
  fi

  # 11. Avoid C source filenames as subject
  if [[ "${COMMIT_SUBJECT}" =~ ^[_a-zA-Z0-9]+\.[ch]$ ]]; then
    add_warning 1 "Avoid using C source filenames as the commit subject"
  fi

  # 12. Avoid "Update filename.c" pattern
  if [[ "$COMMIT_SUBJECT" =~ ^(Update|Modify|Change)[[:space:]]+([^[:space:]]+)$ ]]; then
    local candidate="${BASH_REMATCH[2]}"
    if [[ "$candidate" =~ \.(c|h)$ ]]; then
      add_warning 1 "Avoid using just a filename. Provide a meaningful description"
    fi
  fi

  # 13. Disallow backticks in commit message
  if grep -v '^[[:space:]]*#' "$COMMIT_MSG_FILE" | grep -q '\`'; then
    add_warning 1 "Avoid using backticks in commit messages"
  fi

  # 14. Check for abusive language
  ABUSIVE_REGEX='\b(fuck|fucking|shit|bitch|asshole|cunt|damn|crap|dumbass)\b'
  if grep -v '^[[:space:]]*#' "$COMMIT_MSG_FILE" | grep -Eiq "$ABUSIVE_REGEX"; then
    add_warning 1 "Commit message contains inappropriate language"
  fi
}

# Generate Change-Id for the commit
add_change_id() {
  # Skip if Change-Id already exists
  grep -qi '^Change-Id:' "$COMMIT_MSG_FILE" && return

  # Generate unique ID
  local clean_message
  clean_message=$(sed -e '/^#/d' -e '/^Signed-off-by:/d' "$COMMIT_MSG_FILE" | git stripspace)
  [ -z "$clean_message" ] && return

  local id=$(_gen_changeid)

  # Use git interpret-trailers for safe trailer handling
  local temp_file="${COMMIT_MSG_FILE}.tmp.$$"
  if command -v git >/dev/null 2>&1 && git interpret-trailers --help >/dev/null 2>&1; then
    git interpret-trailers --if-exists doNothing \
      --where end --trailer "Change-Id: I${id}" \
      < "$COMMIT_MSG_FILE" > "$temp_file" && mv "$temp_file" "$COMMIT_MSG_FILE"
  else
    # Fallback: append at end
    echo "" >> "$COMMIT_MSG_FILE"
    echo "Change-Id: I${id}" >> "$COMMIT_MSG_FILE"
  fi
}

_gen_changeid() {
  {
    echo "tree $(git write-tree)"
    # Guard against unborn branch and avoid stray output
    if git rev-parse --verify HEAD >/dev/null 2>&1; then
      echo "parent $(git rev-parse --verify HEAD)"
    fi
    echo "author $(git var GIT_AUTHOR_IDENT)"
    echo "committer $(git var GIT_COMMITTER_IDENT)"
    echo
    sed -e '/^#/d' -e '/^Signed-off-by:/d' "$COMMIT_MSG_FILE" | git stripspace
  } | git hash-object -t commit --stdin
}

# Main execution
set_colors
set_editor
build_trailer_regex

if tty >/dev/null 2>&1; then
  TTY=$(tty)
else
  TTY=/dev/tty
fi

while true; do
  read_commit_message
  validate_commit_message
  add_change_id

  # No warnings - commit is good
  test ${#WARNINGS[@]} -eq 0 && exit 0

  display_warnings

  echo -en "${CYAN}Proceed with commit? [e/n/?] ${NC}"
  read REPLY < "$TTY"

  case "$REPLY" in
    E*|e*) $HOOK_EDITOR "$COMMIT_MSG_FILE" < $TTY; continue ;;
    N*|n*) exit 1 ;;
    *)     SKIP_DISPLAY_WARNINGS=1; prompt_help; continue ;;
  esac
done
